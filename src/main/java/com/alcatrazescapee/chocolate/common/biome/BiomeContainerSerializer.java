/*
 * Part of the Chocolate mod by AlcatrazEscapee.
 * Licensed under the MIT License. See LICENSE.md for details.
 */

package com.alcatrazescapee.chocolate.common.biome;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashSet;
import java.util.List;
import java.util.Optional;
import java.util.Set;
import java.util.stream.Collectors;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import net.minecraft.nbt.NbtCompound;
import net.minecraft.nbt.NbtList;
import net.minecraft.nbt.NbtString;
import net.minecraft.util.Identifier;
import net.minecraft.util.math.ChunkPos;
import net.minecraft.util.registry.Registry;
import net.minecraft.util.registry.RegistryKey;
import net.minecraft.world.World;
import net.minecraft.world.biome.Biome;
import net.minecraft.world.biome.source.BiomeArray;
import net.minecraft.world.biome.source.BiomeSource;

import com.alcatrazescapee.chocolate.common.ChocolateConfig;
import com.alcatrazescapee.chocolate.common.Debug;
import net.fabricmc.fabric.api.util.NbtType;
import org.jetbrains.annotations.Nullable;

/**
 * Advanced {@link BiomeArray} serialization, which stores an additional palette to chunk data.
 */
public final class BiomeContainerSerializer
{
    public static final String PALETTE_KEY = "ChocolateBiomePalette";
    public static final String KEYS_KEY = "Keys";
    public static final String IDS_KEY = "Ids";

    public static final String BIOMES_KEY = "Biomes";

    private static final Logger LOGGER = LogManager.getLogger();

    public static BiomeArray read(Registry<Biome> biomeRegistry, ChunkPos pos, BiomeSource biomeProvider, @Nullable int[] biomeData, NbtCompound nbt, World world)
    {
        if (biomeData != null && nbt.contains(PALETTE_KEY, NbtType.COMPOUND) && Debug.ENABLE_BIOME_FIXES)
        {
            // Read and apply additional palette data
            final NbtCompound paletteNbt = nbt.getCompound(PALETTE_KEY);
            final NbtList keysNbt = paletteNbt.getList(KEYS_KEY, NbtType.STRING);
            final int[] savedIds = paletteNbt.getIntArray(IDS_KEY);
            final int[] actualIds = new int[savedIds.length];
            final List<Identifier> missingBiomeNames = new ArrayList<>();
            for (int i = 0; i < keysNbt.size(); i++)
            {
                final Identifier key = new Identifier(keysNbt.getString(i));
                final Biome biome = biomeRegistry.get(key);
                if (biome != null)
                {
                    actualIds[i] = biomeRegistry.getRawId(biome);
                }
                else
                {
                    actualIds[i] = -1; // Default to -1 with removed biomes - will be re-generated by the biome provider
                    missingBiomeNames.add(key);
                }
            }

            final ChocolateConfig.Severity actionOnMissingBiomes = ChocolateConfig.Severity.LOG; //ChocolateConfig.SERVER.onBiomesRemovedFromChunks.get();
            if (!missingBiomeNames.isEmpty() && actionOnMissingBiomes != ChocolateConfig.Severity.NONE)
            {
                // There will be missing biomes from the world! This is likely due to removing biomes
                LOGGER.error("There are biomes in the chunk which are missing from the world! These will be defaulted: " + missingBiomeNames.stream().map(Identifier::toString).collect(Collectors.joining(", ")));
                if (actionOnMissingBiomes == ChocolateConfig.Severity.THROW)
                {
                    throw new IllegalStateException("Chocolate threw this error according to the config setting onBiomesRemovedFromChunks = THROW. If reporting this, include the full log as it contains the actual text of the error!");
                }
            }

            final Set<Integer> missingIds = new HashSet<>();
            for (int i = 0; i < biomeData.length; i++)
            {
                int biomeId = biomeData[i];
                boolean foundId = false;
                for (int j = 0; j < savedIds.length; j++)
                {
                    if (biomeId == savedIds[j])
                    {
                        biomeData[i] = actualIds[j];
                        foundId = true;
                        break;
                    }
                }

                if (!foundId)
                {
                    // Batch errors together to avoid spamming the log as this is done for every chunk
                    missingIds.add(biomeId);
                }
            }

            final ChocolateConfig.Severity actionOnMissingIds = ChocolateConfig.Severity.LOG; // = ChocolateConfig.SERVER.onIdsMissingFromPalette.get();
            if (!missingIds.isEmpty() && actionOnMissingIds != ChocolateConfig.Severity.NONE)
            {
                // This should never happen, it means somehow the serialization contract was broken
                LOGGER.error("There are int IDs present in the biome container with no entry in the palette!");
                LOGGER.error("The biome palette was: " + paletteNbt);
                LOGGER.error("The biome array was: [" + Arrays.stream(biomeData).mapToObj(String::valueOf).collect(Collectors.joining()) + ']');
                LOGGER.error("The missing int IDs were: " + missingIds);
                if (actionOnMissingIds == ChocolateConfig.Severity.THROW)
                {
                    throw new IllegalStateException("Chocolate threw this error according to the config setting onIdsMissingFromPalette = THROW. If reporting this, include the full log as it contains the actual text of the error!");
                }
            }
        }
        return new BiomeArray(biomeRegistry, world, pos, biomeProvider, biomeData);
    }

    /**
     * Writes a biome container's palette information to the specified nbt tag
     * At this point, the biome container's {@link BiomeArray#toIntArray()} method has already been invoked (which is going to invoke the mixin modified version.
     * Under that assumption, every biome that is written as an int ID will have serialized itself as biome -(bridge)-> key -(registry)-> biome -(registry)-> int ID
     * We are then free to assume this process will hold for all biomes found in the biome container at this point
     *
     * @param biomeContainer The biome container
     * @param nbt            The nbt to put extra palette data onto
     */
    public static void write(@Nullable BiomeArray biomeContainer, NbtCompound nbt)
    {
        if (biomeContainer != null && nbt.contains(BIOMES_KEY) && Debug.ENABLE_BIOME_FIXES)
        {
            // Write additional palette data
            final NbtCompound paletteNbt = new NbtCompound();
            final Registry<Biome> biomeRegistry = ((BiomeContainerBridge) biomeContainer).bridge$getActualBiomeRegistry();
            final Biome[] uniqueBiomes = Arrays.stream(((BiomeContainerBridge) biomeContainer).bridge$getInternalBiomeArray())
                .distinct()
                .toArray(Biome[]::new);
            final int[] ids = new int[uniqueBiomes.length];
            final NbtList keysNbt = new NbtList();

            // This is free of any checks as they have already been performed in BiomeContainer#writeBiomes
            for (int i = 0; i < uniqueBiomes.length; i++) {
                // Use the key on each biome and compute an ID mapping
                final Biome biome = uniqueBiomes[i];
                final Optional<RegistryKey<Biome>> key = ((BiomeContainerBridge) biomeContainer).bridge$getActualBiomeRegistry().getKey(biome);

                if (key.isPresent()) {
                    keysNbt.add(NbtString.of(key.get().getValue().toString()));
                     ids[i] = biomeRegistry.getRawId(biomeRegistry.get(key.get()));
                } else {
                    System.out.println("It went crab.");
                }
            }

            paletteNbt.putIntArray(IDS_KEY, ids);
            paletteNbt.put(KEYS_KEY, keysNbt);
            nbt.put(PALETTE_KEY, paletteNbt);
        }
    }
}
